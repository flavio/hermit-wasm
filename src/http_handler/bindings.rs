// Based on the file generated by wit-import, with one small change to HttpHandler
// attributes. See below

#[allow(clippy::all)]
#[allow(dead_code)]
pub mod http_handler {
    #[allow(unused_imports)]
    use wit_bindgen_wasmi::{anyhow, wasmi};
    /// The HTTP method.
    #[repr(u8)]
    #[derive(Clone, Copy, PartialEq, Eq)]
    pub enum Method {
        Get,
        Post,
        Put,
        Delete,
        Patch,
        Head,
        Options,
    }
    impl core::fmt::Debug for Method {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            match self {
                Method::Get => f.debug_tuple("Method::Get").finish(),
                Method::Post => f.debug_tuple("Method::Post").finish(),
                Method::Put => f.debug_tuple("Method::Put").finish(),
                Method::Delete => f.debug_tuple("Method::Delete").finish(),
                Method::Patch => f.debug_tuple("Method::Patch").finish(),
                Method::Head => f.debug_tuple("Method::Head").finish(),
                Method::Options => f.debug_tuple("Method::Options").finish(),
            }
        }
    }
    /// The HTTP URI of the current request.
    pub type Uri<'a> = &'a str;
    /// The HTTP headers represented as a list of (name, value) pairs.
    pub type HeadersParam<'a> = &'a [(&'a str, &'a str)];
    /// The HTTP headers represented as a list of (name, value) pairs.
    pub type HeadersResult = Vec<(String, String)>;
    /// The HTTP parameter queries, represented as a list of (name, value) pairs.
    pub type Params<'a> = &'a [(&'a str, &'a str)];
    /// The HTTP body.
    pub type BodyParam<'a> = &'a [u8];
    /// The HTTP body.
    pub type BodyResult = Vec<u8>;
    /// An HTTP request.
    #[derive(Clone)]
    pub struct Request<'a> {
        pub method: Method,
        pub uri: Uri<'a>,
        pub headers: HeadersParam<'a>,
        pub params: Params<'a>,
        pub body: Option<BodyParam<'a>>,
    }
    impl<'a> core::fmt::Debug for Request<'a> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            f.debug_struct("Request")
                .field("method", &self.method)
                .field("uri", &self.uri)
                .field("headers", &self.headers)
                .field("params", &self.params)
                .field("body", &self.body)
                .finish()
        }
    }
    /// The HTTP status code.
    pub type HttpStatus = u16;
    /// An HTTP response.
    #[derive(Clone)]
    pub struct Response {
        pub status: HttpStatus,
        pub headers: Option<HeadersResult>,
        pub body: Option<BodyResult>,
    }
    impl core::fmt::Debug for Response {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            f.debug_struct("Response")
                .field("status", &self.status)
                .field("headers", &self.headers)
                .field("body", &self.body)
                .finish()
        }
    }
    /// HTTP errors returned by the runtime.
    #[derive(Clone)]
    pub enum HttpError {
        InvalidUrl(String),
        TimeoutError(String),
        ProtocolError(String),
        StatusError(u16),
        UnexpectedError(String),
    }
    impl core::fmt::Debug for HttpError {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            match self {
                HttpError::InvalidUrl(e) => {
                    f.debug_tuple("HttpError::InvalidUrl").field(e).finish()
                }
                HttpError::TimeoutError(e) => {
                    f.debug_tuple("HttpError::TimeoutError").field(e).finish()
                }
                HttpError::ProtocolError(e) => {
                    f.debug_tuple("HttpError::ProtocolError").field(e).finish()
                }
                HttpError::StatusError(e) => {
                    f.debug_tuple("HttpError::StatusError").field(e).finish()
                }
                HttpError::UnexpectedError(e) => f
                    .debug_tuple("HttpError::UnexpectedError")
                    .field(e)
                    .finish(),
            }
        }
    }

    /// Auxiliary data associated with the wasm exports.
    ///
    /// This is required to be stored within the data of a
    /// `Store<T>` itself so lifting/lowering state can be managed
    /// when translating between the host and wasm.
    #[derive(Default)]
    pub struct HttpHandlerData {}
    pub struct HttpHandler<T> {
        // All these attributes are now public, that's because we need to
        // set our own `handle_http` function, which points to the exported
        // functions defined by spiderlightining's `register_handler` macro
        pub get_state: Box<dyn Fn(&mut T) -> &mut HttpHandlerData + Send + Sync>,
        pub canonical_abi_free: wasmi::TypedFunc<(i32, i32, i32), ()>,
        pub canonical_abi_realloc: wasmi::TypedFunc<(i32, i32, i32, i32), i32>,
        pub handle_http:
            wasmi::TypedFunc<(i32, i32, i32, i32, i32, i32, i32, i32, i32, i32), (i32,)>,
        pub memory: wasmi::Memory,
    }
    impl<T> HttpHandler<T> {
        #[allow(unused_variables)]

        /// Adds any intrinsics, if necessary for this exported wasm
        /// functionality to the `linker` provided.
        ///
        /// The `get_state` closure is required to access the
        /// auxiliary data necessary for these wasm exports from
        /// the general store's state.
        pub fn add_to_linker(
            linker: &mut wasmi::Linker<T>,
            ctx: &mut impl wasmi::AsContextMut<UserState = T>,
            get_state: impl Fn(&mut T) -> &mut HttpHandlerData + Send + Sync + Copy + 'static,
        ) -> anyhow::Result<()> {
            Ok(())
        }

        /// Instantiates the provided `module` using the specified
        /// parameters, wrapping up the result in a structure that
        /// translates between wasm and the host.
        ///
        /// The `linker` provided will have intrinsics added to it
        /// automatically, so it's not necessary to call
        /// `add_to_linker` beforehand. This function will
        /// instantiate the `module` otherwise using `linker`, and
        /// both an instance of this structure and the underlying
        /// `wasmi::Instance` will be returned.
        ///
        /// The `get_state` parameter is used to access the
        /// auxiliary state necessary for these wasm exports from
        /// the general store state `T`.
        pub fn instantiate(
            mut store: impl wasmi::AsContextMut<UserState = T>,
            module: &wasmi::Module,
            linker: &mut wasmi::Linker<T>,
            get_state: impl Fn(&mut T) -> &mut HttpHandlerData + Send + Sync + Copy + 'static,
        ) -> anyhow::Result<(Self, wasmi::Instance)> {
            Self::add_to_linker(linker, &mut store, get_state)?;
            let instance = linker.instantiate(&mut store, module)?.start(&mut store)?;
            Ok((Self::new(store, &instance, get_state)?, instance))
        }

        /// Low-level creation wrapper for wrapping up the exports
        /// of the `instance` provided in this structure of wasm
        /// exports.
        ///
        /// This function will extract exports from the `instance`
        /// defined within `store` and wrap them all up in the
        /// returned structure which can be used to interact with
        /// the wasm module.
        pub fn new(
            mut store: impl wasmi::AsContextMut<UserState = T>,
            instance: &wasmi::Instance,
            get_state: impl Fn(&mut T) -> &mut HttpHandlerData + Send + Sync + Copy + 'static,
        ) -> anyhow::Result<Self> {
            let mut store = store.as_context_mut();
            let canonical_abi_free =
                instance.get_typed_func::<(i32, i32, i32), ()>(&mut store, "canonical_abi_free")?;
            let canonical_abi_realloc = instance
                .get_typed_func::<(i32, i32, i32, i32), i32>(&mut store, "canonical_abi_realloc")?;
            let handle_http = instance
                .get_typed_func::<(i32, i32, i32, i32, i32, i32, i32, i32, i32, i32), (i32,)>(
                    &mut store,
                    "handle-http",
                )?;
            let memory = instance
                .get_memory(&mut store, "memory")
                .ok_or_else(|| anyhow::anyhow!("`memory` export not a memory"))?;
            Ok(HttpHandler {
                canonical_abi_free,
                canonical_abi_realloc,
                handle_http,
                memory,
                get_state: Box::new(get_state),
            })
        }
        pub fn handle_http(
            &self,
            mut caller: impl wasmi::AsContextMut<UserState = T>,
            req: Request<'_>,
        ) -> Result<Result<Response, HttpError>, wasmi::core::Trap> {
            let func_canonical_abi_free = &self.canonical_abi_free;
            let func_canonical_abi_realloc = &self.canonical_abi_realloc;
            let memory = &self.memory;
            let Request {
                method: method0,
                uri: uri0,
                headers: headers0,
                params: params0,
                body: body0,
            } = req;
            let vec1 = uri0;
            let ptr1 =
                func_canonical_abi_realloc.call(&mut caller, (0, 0, 1, vec1.len() as i32))?;
            memory
                .data_mut(&mut caller)
                .store_many(ptr1, vec1.as_bytes())?;
            let vec5 = headers0;
            let len5 = vec5.len() as i32;
            let result5 = func_canonical_abi_realloc.call(&mut caller, (0, 0, 4, len5 * 16))?;
            for (i, e) in vec5.into_iter().enumerate() {
                let base = result5 + (i as i32) * 16;
                {
                    let (t2_0, t2_1) = e;
                    let vec3 = t2_0;
                    let ptr3 = func_canonical_abi_realloc
                        .call(&mut caller, (0, 0, 1, vec3.len() as i32))?;
                    memory
                        .data_mut(&mut caller)
                        .store_many(ptr3, vec3.as_bytes())?;
                    memory
                        .data_mut(&mut caller)
                        .store(base + 4, wit_bindgen_wasmi::rt::as_i32(vec3.len() as i32))?;
                    memory
                        .data_mut(&mut caller)
                        .store(base + 0, wit_bindgen_wasmi::rt::as_i32(ptr3))?;
                    let vec4 = t2_1;
                    let ptr4 = func_canonical_abi_realloc
                        .call(&mut caller, (0, 0, 1, vec4.len() as i32))?;
                    memory
                        .data_mut(&mut caller)
                        .store_many(ptr4, vec4.as_bytes())?;
                    memory
                        .data_mut(&mut caller)
                        .store(base + 12, wit_bindgen_wasmi::rt::as_i32(vec4.len() as i32))?;
                    memory
                        .data_mut(&mut caller)
                        .store(base + 8, wit_bindgen_wasmi::rt::as_i32(ptr4))?;
                }
            }
            let vec9 = params0;
            let len9 = vec9.len() as i32;
            let result9 = func_canonical_abi_realloc.call(&mut caller, (0, 0, 4, len9 * 16))?;
            for (i, e) in vec9.into_iter().enumerate() {
                let base = result9 + (i as i32) * 16;
                {
                    let (t6_0, t6_1) = e;
                    let vec7 = t6_0;
                    let ptr7 = func_canonical_abi_realloc
                        .call(&mut caller, (0, 0, 1, vec7.len() as i32))?;
                    memory
                        .data_mut(&mut caller)
                        .store_many(ptr7, vec7.as_bytes())?;
                    memory
                        .data_mut(&mut caller)
                        .store(base + 4, wit_bindgen_wasmi::rt::as_i32(vec7.len() as i32))?;
                    memory
                        .data_mut(&mut caller)
                        .store(base + 0, wit_bindgen_wasmi::rt::as_i32(ptr7))?;
                    let vec8 = t6_1;
                    let ptr8 = func_canonical_abi_realloc
                        .call(&mut caller, (0, 0, 1, vec8.len() as i32))?;
                    memory
                        .data_mut(&mut caller)
                        .store_many(ptr8, vec8.as_bytes())?;
                    memory
                        .data_mut(&mut caller)
                        .store(base + 12, wit_bindgen_wasmi::rt::as_i32(vec8.len() as i32))?;
                    memory
                        .data_mut(&mut caller)
                        .store(base + 8, wit_bindgen_wasmi::rt::as_i32(ptr8))?;
                }
            }
            let (result11_0, result11_1, result11_2) = match body0 {
                Some(e) => {
                    let vec10 = e;
                    let ptr10 = func_canonical_abi_realloc
                        .call(&mut caller, (0, 0, 1, (vec10.len() as i32) * 1))?;
                    memory.data_mut(&mut caller).store_many(ptr10, &vec10)?;
                    (1i32, ptr10, vec10.len() as i32)
                }
                None => {
                    let e = ();
                    {
                        let () = e;
                        (0i32, 0i32, 0i32)
                    }
                }
            };
            let (result12_0,) = self.handle_http.call(
                &mut caller,
                (
                    method0 as i32,
                    ptr1,
                    vec1.len() as i32,
                    result5,
                    len5,
                    result9,
                    len9,
                    result11_0,
                    result11_1,
                    result11_2,
                ),
            )?;
            let load13 = memory.data_mut(&mut caller).load::<u8>(result12_0 + 0)?;
            Ok(match i32::from(load13) {
                0 => Ok({
                    let load14 = memory.data_mut(&mut caller).load::<u16>(result12_0 + 4)?;
                    let load15 = memory.data_mut(&mut caller).load::<u8>(result12_0 + 8)?;
                    let load25 = memory.data_mut(&mut caller).load::<u8>(result12_0 + 20)?;
                    Response {
                        status: u16::try_from(i32::from(load14)).map_err(bad_int)?,
                        headers: match i32::from(load15) {
                            0 => None,
                            1 => Some({
                                let load16 =
                                    memory.data_mut(&mut caller).load::<i32>(result12_0 + 12)?;
                                let load17 =
                                    memory.data_mut(&mut caller).load::<i32>(result12_0 + 16)?;
                                let len24 = load17;
                                let base24 = load16;
                                let mut result24 = Vec::with_capacity(len24 as usize);
                                for i in 0..len24 {
                                    let base = base24 + i * 16;
                                    result24.push({
                                        let load18 =
                                            memory.data_mut(&mut caller).load::<i32>(base + 0)?;
                                        let load19 =
                                            memory.data_mut(&mut caller).load::<i32>(base + 4)?;
                                        let ptr20 = load18;
                                        let len20 = load19;

                                        let data20 =
                                            copy_slice(&mut caller, memory, ptr20, len20, 1)?;
                                        func_canonical_abi_free
                                            .call(&mut caller, (ptr20, len20, 1))?;
                                        let load21 =
                                            memory.data_mut(&mut caller).load::<i32>(base + 8)?;
                                        let load22 =
                                            memory.data_mut(&mut caller).load::<i32>(base + 12)?;
                                        let ptr23 = load21;
                                        let len23 = load22;

                                        let data23 =
                                            copy_slice(&mut caller, memory, ptr23, len23, 1)?;
                                        func_canonical_abi_free
                                            .call(&mut caller, (ptr23, len23, 1))?;
                                        (
                                            String::from_utf8(data20).map_err(|_| {
                                                wasmi::core::Trap::new("invalid utf-8")
                                            })?,
                                            String::from_utf8(data23).map_err(|_| {
                                                wasmi::core::Trap::new("invalid utf-8")
                                            })?,
                                        )
                                    });
                                }
                                func_canonical_abi_free
                                    .call(&mut caller, (base24, len24 * 16, 4))?;
                                result24
                            }),
                            _ => return Err(invalid_variant("option")),
                        },
                        body: match i32::from(load25) {
                            0 => None,
                            1 => Some({
                                let load26 =
                                    memory.data_mut(&mut caller).load::<i32>(result12_0 + 24)?;
                                let load27 =
                                    memory.data_mut(&mut caller).load::<i32>(result12_0 + 28)?;
                                let ptr28 = load26;
                                let len28 = load27;

                                let data28 = copy_slice(&mut caller, memory, ptr28, len28, 1)?;
                                func_canonical_abi_free.call(&mut caller, (ptr28, len28 * 1, 1))?;
                                data28
                            }),
                            _ => return Err(invalid_variant("option")),
                        },
                    }
                }),
                1 => Err({
                    let load29 = memory.data_mut(&mut caller).load::<u8>(result12_0 + 4)?;
                    match i32::from(load29) {
                        0 => HttpError::InvalidUrl({
                            let load30 =
                                memory.data_mut(&mut caller).load::<i32>(result12_0 + 8)?;
                            let load31 =
                                memory.data_mut(&mut caller).load::<i32>(result12_0 + 12)?;
                            let ptr32 = load30;
                            let len32 = load31;

                            let data32 = copy_slice(&mut caller, memory, ptr32, len32, 1)?;
                            func_canonical_abi_free.call(&mut caller, (ptr32, len32, 1))?;
                            String::from_utf8(data32)
                                .map_err(|_| wasmi::core::Trap::new("invalid utf-8"))?
                        }),
                        1 => HttpError::TimeoutError({
                            let load33 =
                                memory.data_mut(&mut caller).load::<i32>(result12_0 + 8)?;
                            let load34 =
                                memory.data_mut(&mut caller).load::<i32>(result12_0 + 12)?;
                            let ptr35 = load33;
                            let len35 = load34;

                            let data35 = copy_slice(&mut caller, memory, ptr35, len35, 1)?;
                            func_canonical_abi_free.call(&mut caller, (ptr35, len35, 1))?;
                            String::from_utf8(data35)
                                .map_err(|_| wasmi::core::Trap::new("invalid utf-8"))?
                        }),
                        2 => HttpError::ProtocolError({
                            let load36 =
                                memory.data_mut(&mut caller).load::<i32>(result12_0 + 8)?;
                            let load37 =
                                memory.data_mut(&mut caller).load::<i32>(result12_0 + 12)?;
                            let ptr38 = load36;
                            let len38 = load37;

                            let data38 = copy_slice(&mut caller, memory, ptr38, len38, 1)?;
                            func_canonical_abi_free.call(&mut caller, (ptr38, len38, 1))?;
                            String::from_utf8(data38)
                                .map_err(|_| wasmi::core::Trap::new("invalid utf-8"))?
                        }),
                        3 => HttpError::StatusError({
                            let load39 =
                                memory.data_mut(&mut caller).load::<u16>(result12_0 + 8)?;
                            u16::try_from(i32::from(load39)).map_err(bad_int)?
                        }),
                        4 => HttpError::UnexpectedError({
                            let load40 =
                                memory.data_mut(&mut caller).load::<i32>(result12_0 + 8)?;
                            let load41 =
                                memory.data_mut(&mut caller).load::<i32>(result12_0 + 12)?;
                            let ptr42 = load40;
                            let len42 = load41;

                            let data42 = copy_slice(&mut caller, memory, ptr42, len42, 1)?;
                            func_canonical_abi_free.call(&mut caller, (ptr42, len42, 1))?;
                            String::from_utf8(data42)
                                .map_err(|_| wasmi::core::Trap::new("invalid utf-8"))?
                        }),
                        _ => return Err(invalid_variant("HttpError")),
                    }
                }),
                _ => return Err(invalid_variant("expected")),
            })
        }
    }
    use core::convert::TryFrom;
    use wit_bindgen_wasmi::rt::bad_int;
    use wit_bindgen_wasmi::rt::copy_slice;
    use wit_bindgen_wasmi::rt::invalid_variant;
    use wit_bindgen_wasmi::rt::RawMem;
}
